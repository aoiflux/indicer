// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        v6.32.0
// source: dues.proto

package pb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type BaseFile struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	FilePath      string                 `protobuf:"bytes,1,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	FileId        string                 `protobuf:"bytes,2,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	FileSize      int64                  `protobuf:"varint,3,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
	ChunkMap      map[string]int64       `protobuf:"bytes,4,rep,name=chunk_map,json=chunkMap,proto3" json:"chunk_map,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BaseFile) Reset() {
	*x = BaseFile{}
	mi := &file_dues_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BaseFile) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BaseFile) ProtoMessage() {}

func (x *BaseFile) ProtoReflect() protoreflect.Message {
	mi := &file_dues_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BaseFile.ProtoReflect.Descriptor instead.
func (*BaseFile) Descriptor() ([]byte, []int) {
	return file_dues_proto_rawDescGZIP(), []int{0}
}

func (x *BaseFile) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

func (x *BaseFile) GetFileId() string {
	if x != nil {
		return x.FileId
	}
	return ""
}

func (x *BaseFile) GetFileSize() int64 {
	if x != nil {
		return x.FileSize
	}
	return 0
}

func (x *BaseFile) GetChunkMap() map[string]int64 {
	if x != nil {
		return x.ChunkMap
	}
	return nil
}

type AppendIfExistsReq struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	FileHash      string                 `protobuf:"bytes,1,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty"`
	FilePath      string                 `protobuf:"bytes,2,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AppendIfExistsReq) Reset() {
	*x = AppendIfExistsReq{}
	mi := &file_dues_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AppendIfExistsReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AppendIfExistsReq) ProtoMessage() {}

func (x *AppendIfExistsReq) ProtoReflect() protoreflect.Message {
	mi := &file_dues_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AppendIfExistsReq.ProtoReflect.Descriptor instead.
func (*AppendIfExistsReq) Descriptor() ([]byte, []int) {
	return file_dues_proto_rawDescGZIP(), []int{1}
}

func (x *AppendIfExistsReq) GetFileHash() string {
	if x != nil {
		return x.FileHash
	}
	return ""
}

func (x *AppendIfExistsReq) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

type AppendIfExistsRes struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Exists        bool                   `protobuf:"varint,1,opt,name=exists,proto3" json:"exists,omitempty"`
	Appended      bool                   `protobuf:"varint,2,opt,name=appended,proto3" json:"appended,omitempty"`
	EviFile       *BaseFile              `protobuf:"bytes,3,opt,name=evi_file,json=eviFile,proto3" json:"evi_file,omitempty"`
	Err           string                 `protobuf:"bytes,4,opt,name=err,proto3" json:"err,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AppendIfExistsRes) Reset() {
	*x = AppendIfExistsRes{}
	mi := &file_dues_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AppendIfExistsRes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AppendIfExistsRes) ProtoMessage() {}

func (x *AppendIfExistsRes) ProtoReflect() protoreflect.Message {
	mi := &file_dues_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AppendIfExistsRes.ProtoReflect.Descriptor instead.
func (*AppendIfExistsRes) Descriptor() ([]byte, []int) {
	return file_dues_proto_rawDescGZIP(), []int{2}
}

func (x *AppendIfExistsRes) GetExists() bool {
	if x != nil {
		return x.Exists
	}
	return false
}

func (x *AppendIfExistsRes) GetAppended() bool {
	if x != nil {
		return x.Appended
	}
	return false
}

func (x *AppendIfExistsRes) GetEviFile() *BaseFile {
	if x != nil {
		return x.EviFile
	}
	return nil
}

func (x *AppendIfExistsRes) GetErr() string {
	if x != nil {
		return x.Err
	}
	return ""
}

type StreamFileMeta struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	FilePath      string                 `protobuf:"bytes,1,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	FileType      string                 `protobuf:"bytes,2,opt,name=file_type,json=fileType,proto3" json:"file_type,omitempty"` // disk image type (windows_exfat, linux_ext4, something else)
	FileHash      string                 `protobuf:"bytes,3,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamFileMeta) Reset() {
	*x = StreamFileMeta{}
	mi := &file_dues_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamFileMeta) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamFileMeta) ProtoMessage() {}

func (x *StreamFileMeta) ProtoReflect() protoreflect.Message {
	mi := &file_dues_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamFileMeta.ProtoReflect.Descriptor instead.
func (*StreamFileMeta) Descriptor() ([]byte, []int) {
	return file_dues_proto_rawDescGZIP(), []int{3}
}

func (x *StreamFileMeta) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

func (x *StreamFileMeta) GetFileType() string {
	if x != nil {
		return x.FileType
	}
	return ""
}

func (x *StreamFileMeta) GetFileHash() string {
	if x != nil {
		return x.FileHash
	}
	return ""
}

type StreamFileReq struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Payload:
	//
	//	*StreamFileReq_File
	//	*StreamFileReq_FileMeta
	Payload       isStreamFileReq_Payload `protobuf_oneof:"payload"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamFileReq) Reset() {
	*x = StreamFileReq{}
	mi := &file_dues_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamFileReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamFileReq) ProtoMessage() {}

func (x *StreamFileReq) ProtoReflect() protoreflect.Message {
	mi := &file_dues_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamFileReq.ProtoReflect.Descriptor instead.
func (*StreamFileReq) Descriptor() ([]byte, []int) {
	return file_dues_proto_rawDescGZIP(), []int{4}
}

func (x *StreamFileReq) GetPayload() isStreamFileReq_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *StreamFileReq) GetFile() []byte {
	if x != nil {
		if x, ok := x.Payload.(*StreamFileReq_File); ok {
			return x.File
		}
	}
	return nil
}

func (x *StreamFileReq) GetFileMeta() *StreamFileMeta {
	if x != nil {
		if x, ok := x.Payload.(*StreamFileReq_FileMeta); ok {
			return x.FileMeta
		}
	}
	return nil
}

type isStreamFileReq_Payload interface {
	isStreamFileReq_Payload()
}

type StreamFileReq_File struct {
	File []byte `protobuf:"bytes,1,opt,name=file,proto3,oneof"`
}

type StreamFileReq_FileMeta struct {
	FileMeta *StreamFileMeta `protobuf:"bytes,2,opt,name=file_meta,json=fileMeta,proto3,oneof"`
}

func (*StreamFileReq_File) isStreamFileReq_Payload() {}

func (*StreamFileReq_FileMeta) isStreamFileReq_Payload() {}

type StreamFileRes struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Done          bool                   `protobuf:"varint,1,opt,name=done,proto3" json:"done,omitempty"`
	Err           string                 `protobuf:"bytes,2,opt,name=err,proto3" json:"err,omitempty"`
	EviFile       *BaseFile              `protobuf:"bytes,3,opt,name=evi_file,json=eviFile,proto3" json:"evi_file,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamFileRes) Reset() {
	*x = StreamFileRes{}
	mi := &file_dues_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamFileRes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamFileRes) ProtoMessage() {}

func (x *StreamFileRes) ProtoReflect() protoreflect.Message {
	mi := &file_dues_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamFileRes.ProtoReflect.Descriptor instead.
func (*StreamFileRes) Descriptor() ([]byte, []int) {
	return file_dues_proto_rawDescGZIP(), []int{5}
}

func (x *StreamFileRes) GetDone() bool {
	if x != nil {
		return x.Done
	}
	return false
}

func (x *StreamFileRes) GetErr() string {
	if x != nil {
		return x.Err
	}
	return ""
}

func (x *StreamFileRes) GetEviFile() *BaseFile {
	if x != nil {
		return x.EviFile
	}
	return nil
}

type GetEviFilesReq struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetEviFilesReq) Reset() {
	*x = GetEviFilesReq{}
	mi := &file_dues_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetEviFilesReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetEviFilesReq) ProtoMessage() {}

func (x *GetEviFilesReq) ProtoReflect() protoreflect.Message {
	mi := &file_dues_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetEviFilesReq.ProtoReflect.Descriptor instead.
func (*GetEviFilesReq) Descriptor() ([]byte, []int) {
	return file_dues_proto_rawDescGZIP(), []int{6}
}

type GetEviFilesRes struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Done          bool                   `protobuf:"varint,1,opt,name=done,proto3" json:"done,omitempty"`
	Err           string                 `protobuf:"bytes,2,opt,name=err,proto3" json:"err,omitempty"`
	EviFile       []*BaseFile            `protobuf:"bytes,3,rep,name=evi_file,json=eviFile,proto3" json:"evi_file,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetEviFilesRes) Reset() {
	*x = GetEviFilesRes{}
	mi := &file_dues_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetEviFilesRes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetEviFilesRes) ProtoMessage() {}

func (x *GetEviFilesRes) ProtoReflect() protoreflect.Message {
	mi := &file_dues_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetEviFilesRes.ProtoReflect.Descriptor instead.
func (*GetEviFilesRes) Descriptor() ([]byte, []int) {
	return file_dues_proto_rawDescGZIP(), []int{7}
}

func (x *GetEviFilesRes) GetDone() bool {
	if x != nil {
		return x.Done
	}
	return false
}

func (x *GetEviFilesRes) GetErr() string {
	if x != nil {
		return x.Err
	}
	return ""
}

func (x *GetEviFilesRes) GetEviFile() []*BaseFile {
	if x != nil {
		return x.EviFile
	}
	return nil
}

type GetPartiFilesReq struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	EviFileId     string                 `protobuf:"bytes,1,opt,name=evi_file_id,json=eviFileId,proto3" json:"evi_file_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetPartiFilesReq) Reset() {
	*x = GetPartiFilesReq{}
	mi := &file_dues_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetPartiFilesReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetPartiFilesReq) ProtoMessage() {}

func (x *GetPartiFilesReq) ProtoReflect() protoreflect.Message {
	mi := &file_dues_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetPartiFilesReq.ProtoReflect.Descriptor instead.
func (*GetPartiFilesReq) Descriptor() ([]byte, []int) {
	return file_dues_proto_rawDescGZIP(), []int{8}
}

func (x *GetPartiFilesReq) GetEviFileId() string {
	if x != nil {
		return x.EviFileId
	}
	return ""
}

type GetPartiFilesRes struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Done          bool                   `protobuf:"varint,1,opt,name=done,proto3" json:"done,omitempty"`
	Err           string                 `protobuf:"bytes,2,opt,name=err,proto3" json:"err,omitempty"`
	PartitionFile []*BaseFile            `protobuf:"bytes,3,rep,name=partition_file,json=partitionFile,proto3" json:"partition_file,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetPartiFilesRes) Reset() {
	*x = GetPartiFilesRes{}
	mi := &file_dues_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetPartiFilesRes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetPartiFilesRes) ProtoMessage() {}

func (x *GetPartiFilesRes) ProtoReflect() protoreflect.Message {
	mi := &file_dues_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetPartiFilesRes.ProtoReflect.Descriptor instead.
func (*GetPartiFilesRes) Descriptor() ([]byte, []int) {
	return file_dues_proto_rawDescGZIP(), []int{9}
}

func (x *GetPartiFilesRes) GetDone() bool {
	if x != nil {
		return x.Done
	}
	return false
}

func (x *GetPartiFilesRes) GetErr() string {
	if x != nil {
		return x.Err
	}
	return ""
}

func (x *GetPartiFilesRes) GetPartitionFile() []*BaseFile {
	if x != nil {
		return x.PartitionFile
	}
	return nil
}

type GetIdxFilesReq struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PartiFileId   string                 `protobuf:"bytes,1,opt,name=parti_file_id,json=partiFileId,proto3" json:"parti_file_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetIdxFilesReq) Reset() {
	*x = GetIdxFilesReq{}
	mi := &file_dues_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetIdxFilesReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetIdxFilesReq) ProtoMessage() {}

func (x *GetIdxFilesReq) ProtoReflect() protoreflect.Message {
	mi := &file_dues_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetIdxFilesReq.ProtoReflect.Descriptor instead.
func (*GetIdxFilesReq) Descriptor() ([]byte, []int) {
	return file_dues_proto_rawDescGZIP(), []int{10}
}

func (x *GetIdxFilesReq) GetPartiFileId() string {
	if x != nil {
		return x.PartiFileId
	}
	return ""
}

type GetIdxFilesRes struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Done          bool                   `protobuf:"varint,1,opt,name=done,proto3" json:"done,omitempty"`
	Err           string                 `protobuf:"bytes,2,opt,name=err,proto3" json:"err,omitempty"`
	IndexedFile   []*BaseFile            `protobuf:"bytes,3,rep,name=indexed_file,json=indexedFile,proto3" json:"indexed_file,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetIdxFilesRes) Reset() {
	*x = GetIdxFilesRes{}
	mi := &file_dues_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetIdxFilesRes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetIdxFilesRes) ProtoMessage() {}

func (x *GetIdxFilesRes) ProtoReflect() protoreflect.Message {
	mi := &file_dues_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetIdxFilesRes.ProtoReflect.Descriptor instead.
func (*GetIdxFilesRes) Descriptor() ([]byte, []int) {
	return file_dues_proto_rawDescGZIP(), []int{11}
}

func (x *GetIdxFilesRes) GetDone() bool {
	if x != nil {
		return x.Done
	}
	return false
}

func (x *GetIdxFilesRes) GetErr() string {
	if x != nil {
		return x.Err
	}
	return ""
}

func (x *GetIdxFilesRes) GetIndexedFile() []*BaseFile {
	if x != nil {
		return x.IndexedFile
	}
	return nil
}

type SearchReq struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Keyword       string                 `protobuf:"bytes,1,opt,name=keyword,proto3" json:"keyword,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SearchReq) Reset() {
	*x = SearchReq{}
	mi := &file_dues_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SearchReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SearchReq) ProtoMessage() {}

func (x *SearchReq) ProtoReflect() protoreflect.Message {
	mi := &file_dues_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SearchReq.ProtoReflect.Descriptor instead.
func (*SearchReq) Descriptor() ([]byte, []int) {
	return file_dues_proto_rawDescGZIP(), []int{12}
}

func (x *SearchReq) GetKeyword() string {
	if x != nil {
		return x.Keyword
	}
	return ""
}

type SearchRes struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Err             string                 `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	TotalCount      int64                  `protobuf:"varint,2,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
	KeywordCountMap map[string]int64       `protobuf:"bytes,3,rep,name=keyword_count_map,json=keywordCountMap,proto3" json:"keyword_count_map,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *SearchRes) Reset() {
	*x = SearchRes{}
	mi := &file_dues_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SearchRes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SearchRes) ProtoMessage() {}

func (x *SearchRes) ProtoReflect() protoreflect.Message {
	mi := &file_dues_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SearchRes.ProtoReflect.Descriptor instead.
func (*SearchRes) Descriptor() ([]byte, []int) {
	return file_dues_proto_rawDescGZIP(), []int{13}
}

func (x *SearchRes) GetErr() string {
	if x != nil {
		return x.Err
	}
	return ""
}

func (x *SearchRes) GetTotalCount() int64 {
	if x != nil {
		return x.TotalCount
	}
	return 0
}

func (x *SearchRes) GetKeywordCountMap() map[string]int64 {
	if x != nil {
		return x.KeywordCountMap
	}
	return nil
}

var File_dues_proto protoreflect.FileDescriptor

const file_dues_proto_rawDesc = "" +
	"\n" +
	"\n" +
	"dues.proto\x12\x04dues\"\xd5\x01\n" +
	"\bBaseFile\x12\x1b\n" +
	"\tfile_path\x18\x01 \x01(\tR\bfilePath\x12\x17\n" +
	"\afile_id\x18\x02 \x01(\tR\x06fileId\x12\x1b\n" +
	"\tfile_size\x18\x03 \x01(\x03R\bfileSize\x129\n" +
	"\tchunk_map\x18\x04 \x03(\v2\x1c.dues.BaseFile.ChunkMapEntryR\bchunkMap\x1a;\n" +
	"\rChunkMapEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x03R\x05value:\x028\x01\"M\n" +
	"\x11AppendIfExistsReq\x12\x1b\n" +
	"\tfile_hash\x18\x01 \x01(\tR\bfileHash\x12\x1b\n" +
	"\tfile_path\x18\x02 \x01(\tR\bfilePath\"\x84\x01\n" +
	"\x11AppendIfExistsRes\x12\x16\n" +
	"\x06exists\x18\x01 \x01(\bR\x06exists\x12\x1a\n" +
	"\bappended\x18\x02 \x01(\bR\bappended\x12)\n" +
	"\bevi_file\x18\x03 \x01(\v2\x0e.dues.BaseFileR\aeviFile\x12\x10\n" +
	"\x03err\x18\x04 \x01(\tR\x03err\"g\n" +
	"\x0eStreamFileMeta\x12\x1b\n" +
	"\tfile_path\x18\x01 \x01(\tR\bfilePath\x12\x1b\n" +
	"\tfile_type\x18\x02 \x01(\tR\bfileType\x12\x1b\n" +
	"\tfile_hash\x18\x03 \x01(\tR\bfileHash\"e\n" +
	"\rStreamFileReq\x12\x14\n" +
	"\x04file\x18\x01 \x01(\fH\x00R\x04file\x123\n" +
	"\tfile_meta\x18\x02 \x01(\v2\x14.dues.StreamFileMetaH\x00R\bfileMetaB\t\n" +
	"\apayload\"`\n" +
	"\rStreamFileRes\x12\x12\n" +
	"\x04done\x18\x01 \x01(\bR\x04done\x12\x10\n" +
	"\x03err\x18\x02 \x01(\tR\x03err\x12)\n" +
	"\bevi_file\x18\x03 \x01(\v2\x0e.dues.BaseFileR\aeviFile\"\x10\n" +
	"\x0eGetEviFilesReq\"a\n" +
	"\x0eGetEviFilesRes\x12\x12\n" +
	"\x04done\x18\x01 \x01(\bR\x04done\x12\x10\n" +
	"\x03err\x18\x02 \x01(\tR\x03err\x12)\n" +
	"\bevi_file\x18\x03 \x03(\v2\x0e.dues.BaseFileR\aeviFile\"2\n" +
	"\x10GetPartiFilesReq\x12\x1e\n" +
	"\vevi_file_id\x18\x01 \x01(\tR\teviFileId\"o\n" +
	"\x10GetPartiFilesRes\x12\x12\n" +
	"\x04done\x18\x01 \x01(\bR\x04done\x12\x10\n" +
	"\x03err\x18\x02 \x01(\tR\x03err\x125\n" +
	"\x0epartition_file\x18\x03 \x03(\v2\x0e.dues.BaseFileR\rpartitionFile\"4\n" +
	"\x0eGetIdxFilesReq\x12\"\n" +
	"\rparti_file_id\x18\x01 \x01(\tR\vpartiFileId\"i\n" +
	"\x0eGetIdxFilesRes\x12\x12\n" +
	"\x04done\x18\x01 \x01(\bR\x04done\x12\x10\n" +
	"\x03err\x18\x02 \x01(\tR\x03err\x121\n" +
	"\findexed_file\x18\x03 \x03(\v2\x0e.dues.BaseFileR\vindexedFile\"%\n" +
	"\tSearchReq\x12\x18\n" +
	"\akeyword\x18\x01 \x01(\tR\akeyword\"\xd4\x01\n" +
	"\tSearchRes\x12\x10\n" +
	"\x03err\x18\x01 \x01(\tR\x03err\x12\x1f\n" +
	"\vtotal_count\x18\x02 \x01(\x03R\n" +
	"totalCount\x12P\n" +
	"\x11keyword_count_map\x18\x03 \x03(\v2$.dues.SearchRes.KeywordCountMapEntryR\x0fkeywordCountMap\x1aB\n" +
	"\x14KeywordCountMapEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x03R\x05value:\x028\x012\xee\x02\n" +
	"\vDuesService\x12B\n" +
	"\x0eAppendIfExists\x12\x17.dues.AppendIfExistsReq\x1a\x17.dues.AppendIfExistsRes\x128\n" +
	"\n" +
	"StreamFile\x12\x13.dues.StreamFileReq\x1a\x13.dues.StreamFileRes(\x01\x129\n" +
	"\vGetEviFiles\x12\x14.dues.GetEviFilesReq\x1a\x14.dues.GetEviFilesRes\x12?\n" +
	"\rGetPartiFiles\x12\x16.dues.GetPartiFilesReq\x1a\x16.dues.GetPartiFilesRes\x129\n" +
	"\vGetIdxFiles\x12\x14.dues.GetIdxFilesReq\x1a\x14.dues.GetIdxFilesRes\x12*\n" +
	"\x06Search\x12\x0f.dues.SearchReq\x1a\x0f.dues.SearchResB\x0fZ\rindicer/pb;pbb\x06proto3"

var (
	file_dues_proto_rawDescOnce sync.Once
	file_dues_proto_rawDescData []byte
)

func file_dues_proto_rawDescGZIP() []byte {
	file_dues_proto_rawDescOnce.Do(func() {
		file_dues_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_dues_proto_rawDesc), len(file_dues_proto_rawDesc)))
	})
	return file_dues_proto_rawDescData
}

var file_dues_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_dues_proto_goTypes = []any{
	(*BaseFile)(nil),          // 0: dues.BaseFile
	(*AppendIfExistsReq)(nil), // 1: dues.AppendIfExistsReq
	(*AppendIfExistsRes)(nil), // 2: dues.AppendIfExistsRes
	(*StreamFileMeta)(nil),    // 3: dues.StreamFileMeta
	(*StreamFileReq)(nil),     // 4: dues.StreamFileReq
	(*StreamFileRes)(nil),     // 5: dues.StreamFileRes
	(*GetEviFilesReq)(nil),    // 6: dues.GetEviFilesReq
	(*GetEviFilesRes)(nil),    // 7: dues.GetEviFilesRes
	(*GetPartiFilesReq)(nil),  // 8: dues.GetPartiFilesReq
	(*GetPartiFilesRes)(nil),  // 9: dues.GetPartiFilesRes
	(*GetIdxFilesReq)(nil),    // 10: dues.GetIdxFilesReq
	(*GetIdxFilesRes)(nil),    // 11: dues.GetIdxFilesRes
	(*SearchReq)(nil),         // 12: dues.SearchReq
	(*SearchRes)(nil),         // 13: dues.SearchRes
	nil,                       // 14: dues.BaseFile.ChunkMapEntry
	nil,                       // 15: dues.SearchRes.KeywordCountMapEntry
}
var file_dues_proto_depIdxs = []int32{
	14, // 0: dues.BaseFile.chunk_map:type_name -> dues.BaseFile.ChunkMapEntry
	0,  // 1: dues.AppendIfExistsRes.evi_file:type_name -> dues.BaseFile
	3,  // 2: dues.StreamFileReq.file_meta:type_name -> dues.StreamFileMeta
	0,  // 3: dues.StreamFileRes.evi_file:type_name -> dues.BaseFile
	0,  // 4: dues.GetEviFilesRes.evi_file:type_name -> dues.BaseFile
	0,  // 5: dues.GetPartiFilesRes.partition_file:type_name -> dues.BaseFile
	0,  // 6: dues.GetIdxFilesRes.indexed_file:type_name -> dues.BaseFile
	15, // 7: dues.SearchRes.keyword_count_map:type_name -> dues.SearchRes.KeywordCountMapEntry
	1,  // 8: dues.DuesService.AppendIfExists:input_type -> dues.AppendIfExistsReq
	4,  // 9: dues.DuesService.StreamFile:input_type -> dues.StreamFileReq
	6,  // 10: dues.DuesService.GetEviFiles:input_type -> dues.GetEviFilesReq
	8,  // 11: dues.DuesService.GetPartiFiles:input_type -> dues.GetPartiFilesReq
	10, // 12: dues.DuesService.GetIdxFiles:input_type -> dues.GetIdxFilesReq
	12, // 13: dues.DuesService.Search:input_type -> dues.SearchReq
	2,  // 14: dues.DuesService.AppendIfExists:output_type -> dues.AppendIfExistsRes
	5,  // 15: dues.DuesService.StreamFile:output_type -> dues.StreamFileRes
	7,  // 16: dues.DuesService.GetEviFiles:output_type -> dues.GetEviFilesRes
	9,  // 17: dues.DuesService.GetPartiFiles:output_type -> dues.GetPartiFilesRes
	11, // 18: dues.DuesService.GetIdxFiles:output_type -> dues.GetIdxFilesRes
	13, // 19: dues.DuesService.Search:output_type -> dues.SearchRes
	14, // [14:20] is the sub-list for method output_type
	8,  // [8:14] is the sub-list for method input_type
	8,  // [8:8] is the sub-list for extension type_name
	8,  // [8:8] is the sub-list for extension extendee
	0,  // [0:8] is the sub-list for field type_name
}

func init() { file_dues_proto_init() }
func file_dues_proto_init() {
	if File_dues_proto != nil {
		return
	}
	file_dues_proto_msgTypes[4].OneofWrappers = []any{
		(*StreamFileReq_File)(nil),
		(*StreamFileReq_FileMeta)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_dues_proto_rawDesc), len(file_dues_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   16,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_dues_proto_goTypes,
		DependencyIndexes: file_dues_proto_depIdxs,
		MessageInfos:      file_dues_proto_msgTypes,
	}.Build()
	File_dues_proto = out.File
	file_dues_proto_goTypes = nil
	file_dues_proto_depIdxs = nil
}
